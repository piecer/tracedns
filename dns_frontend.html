<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>DNS Monitor</title>
<style>
body{font-family: Arial, sans-serif;max-width:1000px;margin:20px;}
nav{margin-bottom:12px;}
nav button{margin-right:6px;padding:6px 10px;}
.section{display:none;}
.section.active{display:block;}
label{display:block;margin:8px 0;}
textarea,input[type=text], input[type=number]{width:100%;padding:6px;}
button{padding:6px 10px;margin:4px 2px;}
#log{background:#f5f5f5;padding:8px;height:120px;overflow:auto;}
table{width:100%;border-collapse:collapse;margin-top:8px;}
th,td{border:1px solid #ddd;padding:6px;text-align:left;}
#historyBox{height:220px;overflow:auto;background:#fff;border:1px solid #ddd;padding:8px;}
.domain-table input{width:70%;}
.domain-table select{width:25%;}
/* allow long values to wrap and be copyable; show full via title tooltip */
.wrap-cell{white-space:nowrap;overflow-x:auto;max-width:520px;display:block;}
</style>
</head>
<body>
<nav>
  <button id="menuSettings">Settings</button>
  <button id="menuStatus">Status</button>
  <button id="menuQuery">Query</button>
  <button id="menuIPs">All IPs</button>
  <button id="menuValidIPs">Valid IPs</button>
</nav>

<div id="settings" class="section">
  <h3>Settings</h3>
  <div style="margin-bottom:8px">
    <button id="settingsTabDomains">Domain settings</button>
    <button id="settingsTabCustom">Custom decoders</button>
  </div>
  <table class="domain-table" id="domainTable">
    <thead><tr><th>Domain</th><th>Type</th><th>TXT Decode</th><th></th></tr></thead>
    <tbody></tbody>
  </table>
  <button id="addDomain">Add Domain</button>
  <label>Servers (comma separated)
    <input id="servers" type="text" />
  </label>
  <label>Interval (seconds)
    <input id="interval" type="number" min="1" />
  </label>
  <button id="load">Load</button>
  <button id="save">Save</button>
  <button id="force">Force Resolve</button>
  <button id="verifyBtn">Verify</button>
  <div id="verifyResult" style="background:#f8f8f8;padding:8px;max-height:240px;overflow:auto;margin-top:8px;font-family:monospace;"></div>
  <h4>Custom Decoders</h4>
  <div id="customSection" style="display:none">
    <p style="background:#f0f8ff;padding:8px;border:1px solid #e0eef8">Usage guide: New custom decoders are defined as a safe array of steps. Example steps:
      <ul>
        <li><b>regex</b>: extract a group from text using a regular expression. Example: <code>{"op":"regex","pattern":"(\\d{1,3}(?:\\.\\d{1,3}){3})","group":1}</code></li>
        <li><b>base64</b>/<b>urlsafe_b64</b>: Base64 decode</li>
        <li><b>xor_hex</b>: XOR with a hex key (example: <code>{"op":"xor_hex","key":"cafebabe"}</code>)</li>
        <li><b>ascii</b>: convert bytes to ASCII string</li>
      </ul>
      List steps in execution order. First use <em>Preview</em> on a sample TXT, and when the output matches your expectation, click <em>Register</em> to add it to the system.
    </p>

    <label>Name
      <input id="custom_name" type="text" placeholder="decoder_name" />
    </label>
    <label>Steps (JSON array)
      <textarea id="custom_steps" rows="6" placeholder='[{"op":"regex","pattern":"(\\d{1,3}(?:\\.\\d{1,3}){3})","group":1}]'></textarea>
    </label>
    <label>Sample TXT (for preview)
      <input id="custom_sample" type="text" placeholder='example sample txt' />
    </label>
    <div style="margin-top:6px">
      <button id="previewCustom">Preview</button>
      <button id="registerCustom">Register</button>
      <button id="clearCustom">Clear</button>
    </div>
    <div id="customPreviewResult" style="background:#fff7e6;padding:8px;margin-top:6px;white-space:pre-wrap;font-family:monospace;"></div>
    <h5 style="margin-top:10px">Registered Custom Decoders</h5>
    <div id="customList" style="border:1px solid #eee;padding:8px;max-height:220px;overflow:auto;background:#fafafa"></div>
  </div>
  <pre id="log"></pre>
</div>

<div id="status" class="section">
  <h3>Current Status</h3>
  <button id="pauseRefreshBtn" style="margin-bottom:6px;">Pause Auto-Refresh</button>
  <table id="resultsTable">
    <thead><tr><th>Domain</th><th>Type</th><th>Server</th><th>Values</th><th>Decoded IPs</th><th>Decode Method</th><th>Last Seen</th><th>History</th></tr></thead>
    <tbody></tbody>
  </table>
  <h4>Analyzer</h4>
  <div>
    <label>Analysis output:
      <div id="analyzeResult" style="background:#f8f8f8;padding:8px;max-height:200px;overflow:auto;font-family:monospace;"></div>
    </label>
  </div>
  <h4>Domain History</h4>
  <div id="historyBox">Select a domain's "History" button to view events.</div>
</div>

<div id="query" class="section">
  <h3>Query</h3>
  <label>Search value (IP or TXT fragment)
    <input id="queryValue" type="text" placeholder="1.2.3.4 or example-txt" />
  </label>
  <button id="doQuery">Search</button>
  <div id="queryResult"></div>
</div>

<div id="ips" class="section">
  <h3>All IPs</h3>
  <table id="ipsTable">
    <thead><tr><th>IP</th><th>Domains</th><th>Count</th><th>Last Seen</th></tr></thead>
    <tbody></tbody>
  </table>
</div>

<div id="validips" class="section">
  <h3>Valid IPs (currently syntactically valid)</h3>
  <label>Recent seconds:
    <input id="valid_since" type="number" min="0" value="3600" />
    <button id="refreshValidBtn">Refresh</button>
  </label>
  <table id="validIpsTable">
    <thead><tr><th>IP</th><th>Domains</th><th>Count</th><th>Last Seen</th><th>Valid</th></tr></thead>
    <tbody></tbody>
  </table>
</div>

<script>
function showSection(name){
  ['settings','status','query','ips'].forEach(id=>document.getElementById(id).classList.remove('active'));
  document.getElementById(name).classList.add('active');
}
document.getElementById('menuSettings').onclick = ()=> showSection('settings');
document.getElementById('menuStatus').onclick = ()=> showSection('status');
document.getElementById('menuQuery').onclick = ()=> showSection('query');
document.getElementById('menuIPs').onclick = ()=> showSection('ips');
document.getElementById('menuValidIPs').onclick = ()=> showSection('validips');

function log(msg){ document.getElementById('log').textContent += msg + "\n"; }

// Global decoder cache
window.DECODERS = [];

async function loadDecoders(){
  try{
    const r = await fetch('/decoders');
    if(!r.ok) return;
    const j = await r.json();
    if(j){
      window.DECODERS = Array.isArray(j.decoders) ? j.decoders : [];
      window.CUSTOM_DECODERS = Array.isArray(j.custom) ? j.custom : [];
    }
  }catch(e){ /* ignore */ }
}

function addDomainRow(obj){
  const tbody = document.querySelector('#domainTable tbody');
  const tr = document.createElement('tr');
  const tdName = document.createElement('td');
  const inp = document.createElement('input'); inp.type='text'; inp.value = obj && obj.name ? obj.name : '';
  tdName.appendChild(inp);
  const tdType = document.createElement('td');
  const sel = document.createElement('select');
  // Expand supported record type list
  ['A','TXT','AAAA','CNAME','MX','NS','SRV','CAA'].forEach(t=>{ const o = document.createElement('option'); o.value=t; o.text=t; sel.appendChild(o); });
  if(obj && obj.type) sel.value = obj.type.toUpperCase();
  tdType.appendChild(sel);
  const tdDecode = document.createElement('td');
  const selDecode = document.createElement('select');
  // Decoder list is loaded dynamically from the backend; use fallback if not loaded yet
  const FALLBACK_DECODERS = ['cafebabe_xor_base64','plain_base64','btea_variant','xor_ipstring_base64_fixedkey','base64_xor_febabe','base56','safeb64_xor','c2_multiplex'];
  const decs = (window.DECODERS && window.DECODERS.length) ? window.DECODERS : FALLBACK_DECODERS;
  // include custom decoders names as well
  const customNames = (window.CUSTOM_DECODERS || []).map(c=>c.name);
  const finalDecs = (decs || []).concat(customNames.filter(n=>!(decs||[]).includes(n)));
  finalDecs.forEach(t=>{ const o = document.createElement('option'); o.value=t; o.text=t; selDecode.appendChild(o); });
  if(obj && obj.txt_decode) selDecode.value = obj.txt_decode;
  // If type is not TXT, disable decoder selection
  if(!(obj && obj.type && obj.type.toUpperCase() === 'TXT')){
    selDecode.disabled = true;
  }

  // Toggle TXT decoder selection enabled/disabled when type changes
  sel.onchange = function(){
    if(this.value && this.value.toUpperCase() === 'TXT'){
      selDecode.disabled = false;
    } else {
      selDecode.disabled = true;
      // 선택된 디코더 값 제거해서 저장 시 의도치 않은 값 유지 방지
      selDecode.selectedIndex = 0;
    }
  };
  tdDecode.appendChild(selDecode);
  // expose for potential external control
  selDecode.dataset.decoderList = 'dynamic';
  const tdBtn = document.createElement('td');
  const del = document.createElement('button'); del.textContent='Delete'; del.onclick = ()=> { tr.remove(); };
  tdBtn.appendChild(del);
  tr.appendChild(tdName); tr.appendChild(tdType); tr.appendChild(tdDecode); tr.appendChild(tdBtn);
  tbody.appendChild(tr);
}

document.getElementById('addDomain').onclick = ()=> addDomainRow();

// Settings tab switching (domains vs custom decoders)
function showSettingsTab(tab){
  const dom = document.getElementById('domainTable');
  const custom = document.getElementById('customSection');
  if(tab === 'custom'){
    dom.style.display = 'none'; custom.style.display = 'block';
  } else {
    dom.style.display = ''; custom.style.display = 'none';
  }
}
document.getElementById('settingsTabDomains').onclick = ()=> showSettingsTab('domains');
document.getElementById('settingsTabCustom').onclick = ()=> showSettingsTab('custom');

function collectDomainsFromUI(){
  const rows = document.querySelectorAll('#domainTable tbody tr');
  const out = [];
  rows.forEach(r=>{
    const name = (r.querySelector('input').value||'').trim();
    const typ = (r.querySelector('select').value||'A').toUpperCase();
    const txt_decode = r.querySelectorAll('select')[1].value;
    if(name) {
      const obj = {name: name, type: typ};
      if(typ === 'TXT') obj.txt_decode = txt_decode;
      out.push(obj);
    }
  });
  return out;
}

async function loadCfg(){
  try{
    const r = await fetch('/config');
    if(!r.ok){ log('Failed to load config'); return; }
    const j = await r.json();
    if(!j) { log('Invalid config response'); return; }
    document.querySelector('#domainTable tbody').innerHTML = '';
    const domains = j.domains || [];
    if(Array.isArray(domains)) {
      domains.forEach(d=>{
        if(typeof d === 'string') addDomainRow({name:d, type:'A'});
        else if(typeof d === 'object') addDomainRow(d);
      });
    }
    const servers = j.servers || [];
    document.getElementById('servers').value = (Array.isArray(servers) ? servers : []).join(',');
    document.getElementById('interval').value = j.interval || 60;
    log('Loaded config');
  }catch(e){ log('Config load error:'+e); }
}
document.getElementById('load').onclick = loadCfg;

document.getElementById('save').onclick = async ()=>{
  const payload = {
    domains: collectDomainsFromUI(),
    servers: document.getElementById('servers').value.split(',').map(s=>s.trim()).filter(Boolean),
    interval: parseInt(document.getElementById('interval').value) || 60
  };
  try{
    const r = await fetch('/config',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
    const j = await r.json();
    log('Saved: ' + JSON.stringify(j));
  }catch(e){ log('Save error:'+e); }
};

document.getElementById('force').onclick = async ()=>{
  const domains = collectDomainsFromUI();
  try{
    const r = await fetch('/resolve', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({domains: domains})});
    const j = await r.json();
    log('Force requested: '+JSON.stringify(j));
    await refreshResults();
  }catch(e){ log('Force error:'+e); }
};

document.getElementById('verifyBtn').onclick = async ()=>{
  const domains = collectDomainsFromUI();
  const el = document.getElementById('verifyResult');
  el.textContent = 'Running verify...';
  try{
    const r = await fetch('/verify', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({domains: domains})});
    if(!r.ok){ el.textContent = 'Verify request failed: '+r.status; return; }
    const j = await r.json();
    renderVerifyResult(j);
  }catch(e){ el.textContent = 'Verify error: '+e; }
};

function renderVerifyResult(j){
  const el = document.getElementById('verifyResult');
  el.innerHTML = '';
  if(!j || j.error){ el.textContent = j && j.error ? 'Error: '+j.error : 'No result'; return; }
  const res = j.results || {};
  const doms = Object.keys(res).sort();
  if(doms.length===0){ el.textContent = 'No domains verified'; return; }
  doms.forEach(dom=>{
    const block = document.createElement('div');
    block.style.borderBottom='1px solid #eee'; block.style.padding='6px 0';
    const h = document.createElement('div'); h.textContent = dom; h.style.fontWeight='700';
    block.appendChild(h);
    const data = res[dom];
    if(data.error){ const e = document.createElement('div'); e.textContent = 'Error: '+data.error; block.appendChild(e); el.appendChild(block); return; }
    const analysis = data.analysis || {};
    const keys = Object.keys(analysis).sort((a,b)=> (analysis[b].score||0)-(analysis[a].score||0));
    keys.forEach(k=>{
      const info = analysis[k];
      const row = document.createElement('div');
      row.style.margin='6px 0';
      const title = document.createElement('div'); title.textContent = `${k} — score=${info.score} raw=${info.raw_count}`;
      title.style.fontWeight='600';
      row.appendChild(title);
      const ips = info.detailed_ips || [];
      if(ips.length===0){ const none = document.createElement('div'); none.textContent = 'No decoded IPs'; row.appendChild(none); }
      else{
        const tbl = document.createElement('table'); tbl.style.width='100%'; const th = document.createElement('tr'); th.innerHTML='<th>IP</th><th>Valid</th><th>VT(malicious/suspicious)</th><th>VT summary</th>'; tbl.appendChild(th);
        ips.forEach(it=>{
          const tr = document.createElement('tr');
          const tdIp = document.createElement('td'); tdIp.textContent = it.ip||'';
          const tdV = document.createElement('td'); tdV.textContent = it.valid ? 'YES' : 'NO';
          const tdVT = document.createElement('td');
          const tdSum = document.createElement('td');
          if(it.vt){ tdVT.textContent = `${it.vt.malicious||0}/${it.vt.suspicious||0}`; tdSum.textContent = `ASN:${it.vt.asn||''} ${it.vt.country||''}`; }
          else { tdVT.textContent = '-'; tdSum.textContent = '-'; }
          tr.appendChild(tdIp); tr.appendChild(tdV); tr.appendChild(tdVT); tr.appendChild(tdSum); tbl.appendChild(tr);
        });
        row.appendChild(tbl);
      }
      block.appendChild(row);
    });
    el.appendChild(block);
  });
}

async function refreshResults(){
  try{
    const r = await fetch('/results'); 
    if(!r.ok) {
      console.error('refreshResults: HTTP error', r.status);
      return;
    }
    const j = await r.json();
    const tbody = document.querySelector('#resultsTable tbody');
    const results = j.results || {};
    // build a map of existing rows keyed by domain||srv to preserve verify rows and avoid full re-render
    const existing = {};
    Array.from(tbody.querySelectorAll('tr')).forEach(r => {
      if(r.classList && r.classList.contains('verify-row')) return;
      const kd = r.dataset.domain || '';
      const ks = r.dataset.server || '';
      if(kd) existing[kd + '||' + ks] = r;
    });

    const newKeys = [];
    Object.keys(results).sort().forEach(d=>{
      const srvMap = results[d];
      if(typeof srvMap !== 'object') return;
      Object.keys(srvMap).forEach(srv=>{
        const info = srvMap[srv];
        if(typeof info !== 'object') return;
        const key = d + '||' + srv;
        newKeys.push(key);
        let tr = existing[key];
        const fullVals = (info.values||[]).join(' | ');
        const fullDecoded = (info.decoded_ips||[]).join(', ');
        if(tr){
          // update existing row in-place
          tr.dataset.domain = d; tr.dataset.server = srv;
          tr.innerHTML = '';
        } else {
          tr = document.createElement('tr');
          tr.dataset.domain = d; tr.dataset.server = srv;
        }
        const tdDomain = document.createElement('td'); tdDomain.textContent = d;
        const tdType = document.createElement('td'); tdType.textContent = info.type || 'A';
        const tdSrv = document.createElement('td'); tdSrv.textContent = srv;
        const tdVals = document.createElement('td'); tdVals.textContent = fullVals.length > 200 ? fullVals.slice(0,200) + '…' : fullVals; tdVals.title = fullVals; tdVals.className = 'wrap-cell';
        const tdDecoded = document.createElement('td'); tdDecoded.textContent = fullDecoded.length > 200 ? fullDecoded.slice(0,200) + '…' : fullDecoded; tdDecoded.title = fullDecoded; tdDecoded.className = 'wrap-cell';
        const tdMethod = document.createElement('td'); tdMethod.textContent = (info.type === 'TXT' && info.txt_decode) ? info.txt_decode : '-';
        const tdTs = document.createElement('td'); tdTs.textContent = info.ts ? new Date(info.ts*1000).toISOString() : '-';
        const tdHist = document.createElement('td');
        const btn = document.createElement('button'); btn.textContent='History'; btn.onclick = ()=> loadHistory(d);
        tdHist.appendChild(btn);
        if(info.type === 'TXT'){
          const abtn = document.createElement('button'); abtn.textContent = 'Analyze';
          abtn.onclick = async ()=>{
            const sample = (info.values||[]).join('|');
            try{ const r = await fetch('/analyze',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({domain:d,txt:sample})}); const j = await r.json(); renderAnalyzeResult(j);}catch(e){ document.getElementById('analyzeResult').textContent = 'Analyze error: '+e; }
          };
          tdHist.appendChild(abtn);
          const vbtn = document.createElement('button'); vbtn.textContent = 'Verify';
          vbtn.onclick = async ()=>{
            const next = tr.nextElementSibling;
            if(next && next.classList && next.classList.contains('verify-row') && next.dataset && next.dataset.domain===d){ next.remove(); return; }
            const vtr = document.createElement('tr'); vtr.className = 'verify-row'; vtr.dataset.domain = d;
            const vtd = document.createElement('td'); vtd.colSpan = 8; vtd.textContent = 'Verifying '+d+'...'; vtr.appendChild(vtd);
            tr.parentNode.insertBefore(vtr, tr.nextSibling);
            try{ const r = await fetch('/verify',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({domains:[d]})}); const j = await r.json(); vtd.innerHTML=''; if(j && j.results && j.results[d]){ const data = j.results[d]; if(data.error){ vtd.textContent = 'Error: '+data.error; } else { const analysis = data.analysis||{}; const keys = Object.keys(analysis).sort((a,b)=>(analysis[b].score||0)-(analysis[a].score||0)); keys.forEach(k=>{ const info = analysis[k]; const h = document.createElement('div'); h.style.fontWeight='600'; h.textContent = `${k} — score=${info.score} raw=${info.raw_count}`; vtd.appendChild(h); const ips = info.detailed_ips||[]; if(ips.length===0){ const none=document.createElement('div'); none.textContent='No decoded IPs'; vtd.appendChild(none);} else{ const tbl=document.createElement('table'); tbl.style.width='100%'; tbl.style.marginTop='6px'; const thr=document.createElement('tr'); thr.innerHTML='<th>IP</th><th>Valid</th><th>VT(malicious/suspicious)</th><th>Summary</th>'; tbl.appendChild(thr); ips.forEach(it=>{ const trr=document.createElement('tr'); const tdIp=document.createElement('td'); tdIp.textContent=it.ip||''; const tdV=document.createElement('td'); tdV.textContent=it.valid?'YES':'NO'; const tdVT=document.createElement('td'); const tdSum=document.createElement('td'); if(it.vt){ tdVT.textContent=`${it.vt.malicious||0}/${it.vt.suspicious||0}`; tdSum.textContent=`ASN:${it.vt.asn||''} ${it.vt.country||''}`; } else { tdVT.textContent='-'; tdSum.textContent='-'; } trr.appendChild(tdIp); trr.appendChild(tdV); trr.appendChild(tdVT); trr.appendChild(tdSum); tbl.appendChild(trr); }); vtd.appendChild(tbl);} }); } } else { vtd.textContent='No data returned'; } }catch(e){ vtd.textContent='Verify error: '+e; } };
          tdHist.appendChild(vbtn);
        }
        tdHist.appendChild(btn);
        tr.appendChild(tdDomain); tr.appendChild(tdType); tr.appendChild(tdSrv); tr.appendChild(tdVals); tr.appendChild(tdDecoded); tr.appendChild(tdMethod); tr.appendChild(tdTs); tr.appendChild(tdHist);

        // insert or move row into tbody in desired order
        const existingRow = tbody.querySelector(`tr[data-domain="${d}"][data-server="${srv}"]`);
        if(existingRow){
          // replace in-place
          existingRow.parentNode.replaceChild(tr, existingRow);
        } else {
          tbody.appendChild(tr);
        }
      });
    });
    // remove any stale rows (and their verify rows) not present in newKeys
    Array.from(tbody.querySelectorAll('tr')).forEach(r=>{
      if(r.classList && r.classList.contains('verify-row')) return;
      const key = (r.dataset.domain||'') + '||' + (r.dataset.server||'');
      if(!newKeys.includes(key)){
        // remove associated verify row if any
        const next = r.nextElementSibling;
        if(next && next.classList && next.classList.contains('verify-row') && next.dataset && next.dataset.domain===r.dataset.domain){ next.remove(); }
        r.remove();
      }
    });
  }catch(e){ console.log('refresh error', e); }
}

async function loadHistory(domain){
  try{
    const r = await fetch('/history?domain='+encodeURIComponent(domain));
    if(!r.ok) { log('history load failed'); return; }
    const j = await r.json();
    const el = document.getElementById('historyBox');
    // j.history is in the format { meta: {...}, events: [...], current: {...} }
    const hist = j.history || {};
    const events = hist.events || [];
    const meta = hist.meta || {};
    
    if(!events || events.length === 0) {
      el.textContent = 'No history for ' + domain + 
        (meta.first_seen ? '\nFirst seen: ' + new Date(meta.first_seen*1000).toISOString() : '') +
        (meta.last_changed ? '\nLast changed: ' + new Date(meta.last_changed*1000).toISOString() : '');
      return;
    }
    
    const lines = ['History for ' + domain];
    if(meta.first_seen) lines.push('First seen: ' + new Date(meta.first_seen*1000).toISOString());
    if(meta.last_changed) lines.push('Last changed: ' + new Date(meta.last_changed*1000).toISOString());
    lines.push('---');
    
    events.forEach(h=>{
      const t = new Date(h.ts*1000).toISOString();
      if(h.new && h.old){
        lines.push(`${t} [${h.server}] (${h.type}) ${ (h.old.values||[]).join(',') } -> ${ (h.new.values||[]).join(',') }`);
      } else if(h.values){
        lines.push(`${t} [${h.server}] (${h.type}) ${ (h.values||[]).join(',') }`);
      } else {
        lines.push(JSON.stringify(h));
      }
    });
    el.textContent = lines.join('\n');
  }catch(e){ log('history error:'+e); }
}

document.getElementById('doQuery').onclick = async ()=>{
  const v = document.getElementById('queryValue').value.trim();
  if(!v){ alert('Enter search value'); return; }
  // try IP first via /ip, then fallback to scanning /results/history via backend? use /ip for IPs only
  const ipPattern = /^(\d{1,3}\.){3}\d{1,3}$/;
  if(ipPattern.test(v)){
    const r = await fetch('/ip?ip='+encodeURIComponent(v));
    const j = await r.json();
    document.getElementById('queryResult').textContent = JSON.stringify(j, null, 2);
  } else {
    // search value across history/current by fetching /results + /history client-side (simple approach)
    const r1 = await fetch('/results'); const res = await r1.json();
    const matches = [];
    for(const d of Object.keys(res.results||{})){
      const srvMap = res.results[d];
      for(const s of Object.keys(srvMap)){
        const info = srvMap[s];
        if((info.values||[]).some(x=>x.includes(v))){
          matches.push({domain:d, server:s, type:info.type, ts:info.ts, values:info.values});
        }
      }
    }
    // also check histories
    const r2 = await fetch('/history?domain=ALL'); // not implemented server-side to return all; instead fetch each domain
    // fallback: fetch history per domain from results list
    const histMatches = [];
    for(const d of Object.keys(res.results||{})){
      const hresp = await fetch('/history?domain='+encodeURIComponent(d));
      const hj = await hresp.json();
      (hj.history||[]).forEach(ev=>{
        if(ev.new && (ev.new.values||[]).some(x=>x.includes(v)) || ev.old && (ev.old.values||[]).some(x=>x.includes(v))){
          histMatches.push({domain:d, server:ev.server, ts:ev.ts, old:ev.old, new:ev.new});
        } else if(ev.values && (ev.values||[]).some(x=>x.includes(v))){
          histMatches.push({domain:d, server:ev.server, ts:ev.ts, values:ev.values});
        }
      });
    }
    document.getElementById('queryResult').textContent = JSON.stringify({current:matches, history:histMatches}, null, 2);
  }
};

async function refreshIPs(){
  try{
    const r = await fetch('/ips');
    if(!r.ok) {
      console.error('refreshIPs: HTTP error', r.status);
      return;
    }
    const j = await r.json();
    const tbody = document.querySelector('#ipsTable tbody');
    tbody.innerHTML = '';
    const arr = j.ips || [];
    if(!Array.isArray(arr)) {
      console.error('refreshIPs: ips is not an array', arr);
      return;
    }
    arr.forEach(it=>{
      if(typeof it !== 'object') return;
      const tr = document.createElement('tr');
      const tdIp = document.createElement('td'); tdIp.textContent = it.ip || '';
      const tdDomains = document.createElement('td'); tdDomains.textContent = (it.domains||[]).join(', ');
      const tdCount = document.createElement('td'); tdCount.textContent = it.count || 0;
      const tdTs = document.createElement('td'); tdTs.textContent = it.last_ts ? new Date(it.last_ts*1000).toISOString() : '-';
      tr.appendChild(tdIp); tr.appendChild(tdDomains); tr.appendChild(tdCount); tr.appendChild(tdTs);
      tbody.appendChild(tr);
    });
  }catch(e){ console.log('refreshIPs error', e); }
}

function renderAnalyzeResult(j){
  const el = document.getElementById('analyzeResult');
  el.innerHTML = '';
  if(!j || j.error){ el.textContent = j && j.error ? 'Error: '+j.error : 'No result'; return; }
  const analysis = j.analysis || {};
  const keys = Object.keys(analysis);
  if(keys.length === 0){ el.textContent = 'No matching decoders'; return; }
  // find best
  let best = null; let bestScore = -999;
  keys.forEach(k=>{ const s = analysis[k].score || 0; if(s>bestScore){ bestScore=s; best=k; } });

  const title = document.createElement('div'); title.textContent = `Recommendation: ${best} (score=${analysis[best].score})`; title.style.fontWeight='bold'; title.style.marginBottom='6px';
  el.appendChild(title);

  keys.sort((a,b)=> (analysis[b].score||0) - (analysis[a].score||0));
  keys.forEach(k=>{
    const info = analysis[k];
    const box = document.createElement('div');
    box.style.borderBottom='1px solid #eee'; box.style.padding='6px 0';
    if(k===best) box.style.background='#fff7e6';
    const h = document.createElement('div'); h.textContent = `${k} — score=${info.score} raw_count=${info.raw_count}`;
    h.style.fontWeight = (k===best)?'700':'400';
    const ips = document.createElement('div'); ips.textContent = 'ips: ' + (info.ips||[]).join(', ');
    ips.style.marginTop='4px';
    box.appendChild(h); box.appendChild(ips);
    el.appendChild(box);
  });
}

async function refreshValidIPs(){
  try{
    const r = await fetch('/ips');
    if(!r.ok){ console.error('refreshValidIPs HTTP', r.status); return; }
    const j = await r.json();
    const tbody = document.querySelector('#validIpsTable tbody');
    tbody.innerHTML = '';
    const arr = j.ips || [];
    if(!Array.isArray(arr)) return;
    // display only syntactically valid IPs (backend also provides 'valid')
    arr.filter(it => it && it.valid).forEach(it=>{
      const tr = document.createElement('tr');
      const tdIp = document.createElement('td'); tdIp.textContent = it.ip || '';
      const tdDomains = document.createElement('td'); tdDomains.textContent = (it.domains||[]).join(', ');
      const tdCount = document.createElement('td'); tdCount.textContent = it.count || 0;
      const tdTs = document.createElement('td'); tdTs.textContent = it.last_ts ? new Date(it.last_ts*1000).toISOString() : '-';
      const tdValid = document.createElement('td'); tdValid.textContent = it.valid ? 'YES' : 'NO';
      tr.appendChild(tdIp); tr.appendChild(tdDomains); tr.appendChild(tdCount); tr.appendChild(tdTs); tr.appendChild(tdValid);
      tbody.appendChild(tr);
    });
  }catch(e){ console.log('refreshValidIPs error', e); }
}

  // Auto-refresh control
  let manualPause = false; // user toggled pause
  let hoverPause = false;  // temporary pause while hovering over results

  function isPaused(){ return manualPause || hoverPause; }

  document.getElementById('pauseRefreshBtn').onclick = function(){
    manualPause = !manualPause;
    this.textContent = manualPause ? 'Resume Auto-Refresh' : 'Pause Auto-Refresh';
    if(!manualPause){ refreshResults(); refreshIPs(); }
  };

  // pause when user hovers results table to allow inspection of long URLs
  const resultsTable = document.getElementById('resultsTable');
  resultsTable.addEventListener('mouseenter', ()=>{ hoverPause = true; });
  resultsTable.addEventListener('mouseleave', ()=>{ hoverPause = false; });

  // periodic refresh — skip work if paused to avoid wiping user's view
  setInterval(()=>{ if(!isPaused()) refreshResults(); }, 5000);
  setInterval(()=>{ if(!isPaused()) refreshIPs(); }, 5000);

  window.onload = function(){ showSection('settings'); showSettingsTab('domains'); loadCfg(); refreshResults(); refreshIPs(); };
// initialize dynamic decoders and valid IPs refresh hook
window.addEventListener('load', ()=>{
  loadDecoders().then(()=>{
    // reload config so domain rows pick up decoders if possible
    loadCfg();
  });
  document.getElementById('refreshValidBtn').onclick = ()=>{
    const s = parseInt(document.getElementById('valid_since').value) || 0;
    refreshValidIPs(s);
  };
  // initial load of valid ips
  refreshValidIPs(parseInt(document.getElementById('valid_since').value) || 0);
  // custom decoder UI handlers
  function renderCustomList(){
    const el = document.getElementById('customList'); el.innerHTML='';
    const arr = window.CUSTOM_DECODERS || [];
    if(!arr.length){ el.textContent = 'No custom decoders registered'; return; }
    arr.forEach(c=>{
      const row = document.createElement('div'); row.style.borderBottom='1px solid #eee'; row.style.padding='6px 0';
      const title = document.createElement('div'); title.textContent = c.name; title.style.fontWeight='700'; row.appendChild(title);
      const btnRow = document.createElement('div'); btnRow.style.marginTop='6px';
      const edit = document.createElement('button'); edit.textContent='Edit'; edit.onclick = ()=>{
        document.getElementById('custom_name').value = c.name; document.getElementById('custom_name').disabled = true;
        document.getElementById('custom_steps').value = JSON.stringify(c.steps, null, 2);
        document.getElementById('customPreviewResult').textContent = 'Editing '+c.name+' — change steps and click Update';
      };
      const del = document.createElement('button'); del.textContent='Delete'; del.onclick = async ()=>{
        if(!confirm('Delete decoder '+c.name+' ?')) return;
        try{
          const r = await fetch('/decoders/custom',{method:'DELETE',headers:{'Content-Type':'application/json'},body:JSON.stringify({name:c.name})});
          const j = await r.json();
          if(j && j.status === 'ok'){ document.getElementById('customPreviewResult').textContent = 'Deleted '+c.name; await loadDecoders(); renderCustomList(); loadCfg(); }
          else { document.getElementById('customPreviewResult').textContent = 'Delete failed: '+JSON.stringify(j); }
        }catch(e){ document.getElementById('customPreviewResult').textContent = 'Delete error: '+e; }
      };
      const upd = document.createElement('button'); upd.textContent='Update'; upd.onclick = async ()=>{
        const stepsRaw = document.getElementById('custom_steps').value.trim(); let steps;
        try{ steps = JSON.parse(stepsRaw); }catch(e){ alert('Invalid JSON: '+e); return; }
        try{
          const r = await fetch('/decoders/custom',{method:'PUT',headers:{'Content-Type':'application/json'},body:JSON.stringify({name:c.name,steps:steps})});
          const j = await r.json();
          if(j && j.status === 'ok'){ document.getElementById('customPreviewResult').textContent = 'Updated '+c.name; await loadDecoders(); renderCustomList(); loadCfg(); document.getElementById('custom_name').disabled = false; }
          else { document.getElementById('customPreviewResult').textContent = 'Update failed: '+JSON.stringify(j); }
        }catch(e){ document.getElementById('customPreviewResult').textContent = 'Update error: '+e; }
      };
      btnRow.appendChild(edit); btnRow.appendChild(upd); btnRow.appendChild(del); row.appendChild(btnRow);
      el.appendChild(row);
    });
  }

  document.getElementById('previewCustom').onclick = async ()=>{
    const stepsRaw = document.getElementById('custom_steps').value.trim();
    const sample = document.getElementById('custom_sample').value;
    let steps;
    try{ steps = JSON.parse(stepsRaw); }catch(e){ document.getElementById('customPreviewResult').textContent = 'Invalid JSON: '+e; return; }
    try{
      const r = await fetch('/decoders/custom/preview',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({steps: steps, sample: sample})});
      const j = await r.json();
      document.getElementById('customPreviewResult').textContent = JSON.stringify(j, null, 2);
    }catch(e){ document.getElementById('customPreviewResult').textContent = 'Preview error: '+e; }
  };

  document.getElementById('registerCustom').onclick = async ()=>{
    const name = document.getElementById('custom_name').value.trim();
    const stepsRaw = document.getElementById('custom_steps').value.trim();
    if(!name){ alert('Provide a name'); return; }
    let steps;
    try{ steps = JSON.parse(stepsRaw); }catch(e){ alert('Invalid JSON steps: '+e); return; }
    try{
      const r = await fetch('/decoders/custom',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({name: name, steps: steps})});
      const j = await r.json();
      if(j && j.status === 'ok'){
        document.getElementById('customPreviewResult').textContent = 'Registered: '+name;
        // reload decoders and UI
        await loadDecoders();
        renderCustomList();
        loadCfg();
      } else {
        document.getElementById('customPreviewResult').textContent = 'Register failed: '+JSON.stringify(j);
      }
    }catch(e){ document.getElementById('customPreviewResult').textContent = 'Register error: '+e; }
  };
  document.getElementById('clearCustom').onclick = ()=>{
    document.getElementById('custom_name').value='';
    document.getElementById('custom_steps').value='';
    document.getElementById('custom_sample').value='';
    document.getElementById('custom_name').disabled = false;
    document.getElementById('customPreviewResult').textContent='';
  };
  // render custom list initially
  renderCustomList();
});
</script>
</body>
</html>
