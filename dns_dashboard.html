<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TraceDNS Dashboard</title>
  <style>
    body{font-family: Arial, Helvetica, sans-serif; margin:20px}
    h1{font-size:1.4em}
    table{border-collapse:collapse;width:100%}
    th,td{border:1px solid #ddd;padding:8px}
    th{background:#f2f2f2}
    .small{font-size:0.9em;color:#666}
    .vt-bad{background:#fee}
  </style>
</head>
<body>
  <h1>TraceDNS — Global Dashboard</h1>
  <p class="small">Default dashboard. Page last updated at <span id="last">-</span>.</p>

  <div>
    <button id="refresh">Refresh</button>
    <a href="/dns_frontend.html">Domain settings</a>
    &nbsp;|&nbsp;
    <a href="/settings.html">Settings</a>
  </div>

  <h2>Summary</h2>
  <div id="summary">Loading...</div>

  <h2>Unique IPs (VT info included)</h2>
  <table id="ips">
    <thead><tr>
      <th data-key="ip">IP</th>
      <th data-key="count">Count</th>
      <th data-key="last_ts">Last seen</th>
      <th data-key="domains">Domains</th>
      <th data-key="vt">VT</th>
    </tr></thead>
    <tbody></tbody>
  </table>

  <h2>Domains</h2>
  <div id="domains_section">
    <p class="small">List of configured domains and quick actions (remove non-resolving domains).</p>
    <div style="margin-bottom:8px">
      <label><input id="filter_nonresolving" type="checkbox"/> Show only non-resolving</label>
      &nbsp;&nbsp;
      <label>Sort: <select id="domains_sort">
        <option value="resolving_desc">Resolving first</option>
        <option value="last_ts_desc">Last seen (newest)</option>
        <option value="last_ts_asc">Last seen (oldest)</option>
        <option value="name_asc">Name A→Z</option>
        <option value="name_desc">Name Z→A</option>
      </select></label>
    </div>
    <table id="domains_table">
      <thead><tr><th data-key="name">Domain</th><th data-key="type">Type</th><th data-key="resolving">Resolving</th><th data-key="last_ts">Last seen</th><th>Actions</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <h2>Settings</h2>
  <div id="settings">
    <p class="small">Alert template settings (Teams, MISP). Please test integrations manually.</p>
    <label>Teams Webhook URL<br/><input id="teams_webhook" style="width:100%" placeholder="https://..."/></label><br/>
    <label>MISP URL<br/><input id="misp_url" style="width:100%" placeholder="https://misp.example"/></label><br/>
    <label>MISP API Key<br/><input id="misp_key" style="width:100%" placeholder="API key"/></label><br/>
    <label>Push Event ID (MISP)<br/><input id="push_event_id" style="width:100%" placeholder="12345"/></label><br/>
    <label>VirusTotal API Key<br/><input id="vt_api_key" style="width:100%" placeholder="VT API key"/></label><br/>
    <div style="margin-top:6px">
      <button id="load_settings">Load</button>
      <button id="save_settings">Save</button>
      <span id="settings_status" class="small"></span>
    </div>
  </div>

  <script>
    async function load(){
      document.getElementById('last').textContent = new Date().toLocaleString();
      try{
        const resp = await fetch('/ips?include_vt=1');
        if(!resp.ok){
          document.getElementById('summary').textContent = 'Load failed (server error)';
          return;
        }
        const data = await resp.json();
        let ips = data.ips || [];
        document.getElementById('summary').textContent = `Unique IPs: ${ips.length}`;
        // Default: sort by newest (last_ts) descending
        ips.sort((a,b)=> (b.last_ts||0) - (a.last_ts||0));
        const tbody = document.querySelector('#ips tbody');
        tbody.innerHTML = '';
        for(const r of ips){
            const tr = document.createElement('tr');
            if(r.vt && (r.vt.malicious || r.vt.suspicious)) tr.className='vt-bad';
            const last = r.last_ts ? new Date(r.last_ts*1000).toLocaleString() : '';
            const domains = (r.domains||[]).join(', ');
            const vtcell = r.vt ? `<div>malicious:${r.vt.malicious||0} / suspicious:${r.vt.suspicious||0} / harmless:${r.vt.harmless||0}</div>` : '<div class="small">(no VT)</div>';
            tr.innerHTML = `<td><a href="/ip?ip=${encodeURIComponent(r.ip)}">${r.ip}</a></td><td>${r.count}</td><td>${last}</td><td>${domains}</td><td>${vtcell}</td>`;
            tbody.appendChild(tr);
        }
      }catch(e){
        console.error('Failed to load /ips', e);
        document.getElementById('summary').textContent = 'Load failed (network error)';
        return;
      }
    }

    // Sorting logic for table headers
    let currentSort = {key:'last_ts',dir:-1}; // -1 = desc, 1 = asc
    function renderSorted(ips){
      const tbody = document.querySelector('#ips tbody');
      tbody.innerHTML = '';
      for(const r of ips){
        const tr = document.createElement('tr');
        if(r.vt && (r.vt.malicious || r.vt.suspicious)) tr.className='vt-bad';
        const last = r.last_ts ? new Date(r.last_ts*1000).toLocaleString() : '';
        const domains = (r.domains||[]).join(', ');
        const vtcell = r.vt ? `<div>malicious:${r.vt.malicious||0} / suspicious:${r.vt.suspicious||0} / harmless:${r.vt.harmless||0}</div>` : '<div class="small">(no VT)</div>';
        tr.innerHTML = `<td><a href="/ip?ip=${encodeURIComponent(r.ip)}">${r.ip}</a></td><td>${r.count}</td><td>${last}</td><td>${domains}</td><td>${vtcell}</td>`;
        tbody.appendChild(tr);
      }
    }

    function doSort(ips, key, dir){
      const copy = ips.slice();
      copy.sort((a,b)=>{
        const aval = (key==='domains') ? (a.domains||[]).join(', ') : (key==='vt' ? (a.vt && (a.vt.malicious||0)) : (a[key]===undefined? -Infinity : a[key]));
        const bval = (key==='domains') ? (b.domains||[]).join(', ') : (key==='vt' ? (b.vt && (b.vt.malicious||0)) : (b[key]===undefined? -Infinity : b[key]));
        if(typeof aval === 'string' || typeof bval === 'string'){
          return dir * String(aval).localeCompare(String(bval));
        }
        return dir * ( (aval||0) - (bval||0) );
      });
      return copy;
    }

    // Attach header click handlers for sorting (script is at page bottom so DOM is available)
    const headers = document.querySelectorAll('#ips thead th');
    headers.forEach(h=>{
      h.style.cursor = 'pointer';
      h.addEventListener('click', async ()=>{
        const key = h.getAttribute('data-key');
        if(currentSort.key===key) currentSort.dir *= -1; else { currentSort.key=key; currentSort.dir=-1; }
        // reload data and apply sort
        try{
          const resp = await fetch('/ips?include_vt=1');
          if(!resp.ok){
            document.getElementById('summary').textContent = 'Load failed (server error)';
            return;
          }
          const data = await resp.json();
          let ips2 = data.ips || [];
          ips2 = doSort(ips2, currentSort.key, currentSort.dir);
          renderSorted(ips2);
        }catch(e){
          console.error('Failed to load /ips for sorting', e);
          document.getElementById('summary').textContent = 'Load failed (network error)';
        }
      });
    });

    // Domains management
    // domains cache and rendering helpers
    let domainsCache = [];
    function renderDomains(){
      const tbody = document.querySelector('#domains_table tbody');
      tbody.innerHTML = '';
      const onlyNon = document.getElementById('filter_nonresolving').checked;
      let list = domainsCache.slice();
      // apply filter
      if(onlyNon) list = list.filter(x=> !x.resolving);
      // apply sort
      const sortVal = document.getElementById('domains_sort').value;
      if(sortVal === 'resolving_desc'){
        list.sort((a,b)=> (Number(b.resolving) - Number(a.resolving)) || ((b.last_ts||0)-(a.last_ts||0)));
      } else if(sortVal === 'last_ts_desc'){
        list.sort((a,b)=> (b.last_ts||0)-(a.last_ts||0));
      } else if(sortVal === 'last_ts_asc'){
        list.sort((a,b)=> (a.last_ts||0)-(b.last_ts||0));
      } else if(sortVal === 'name_asc'){
        list.sort((a,b)=> String(a.name).localeCompare(String(b.name)));
      } else if(sortVal === 'name_desc'){
        list.sort((a,b)=> String(b.name).localeCompare(String(a.name)));
      }
      for(const d of list){
        const tr = document.createElement('tr');
        const last = d.last_ts ? new Date(d.last_ts*1000).toLocaleString() : '';
        const resolving = d.resolving ? '<strong style="color:green">Yes</strong>' : '<span style="color:#999">No</span>';
        tr.innerHTML = `<td>${d.name}</td><td>${d.type||'A'}</td><td>${resolving}</td><td>${last}</td><td><button data-domain="${d.name}" class="check-domain">Check Now</button> <button data-domain="${d.name}" class="remove-domain">Remove</button></td>`;
        tbody.appendChild(tr);
      }
      // attach handlers
      document.querySelectorAll('.remove-domain').forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          const dom = btn.getAttribute('data-domain');
          if(!confirm(`Remove domain '${dom}' from configuration?`)) return;
          try{
            // fetch current domains list via /domains and POST updated config
            const cur = await fetch('/domains');
            const cj = await cur.json();
            const curList = (cj.domains||[]).map(x=>x.name);
            const newList = curList.filter(x=> x !== dom);
            const r = await fetch('/config', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({domains: newList})});
            const jr = await r.json();
            if(r.ok && jr.status=='ok'){
              await loadDomains(); load();
            } else {
              alert('Failed to remove domain');
            }
          }catch(e){
            console.error('remove domain failed', e);
            alert('Failed to remove domain');
          }
        });
      });
      document.querySelectorAll('.check-domain').forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          const dom = btn.getAttribute('data-domain');
          btn.disabled = true; btn.textContent = 'Checking...';
          try{
            const r = await fetch('/resolve', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({domain: dom})});
            if(r.ok){
              // small delay to allow monitor to run the check
              setTimeout(async ()=>{ await loadDomains(); await load(); btn.disabled=false; btn.textContent='Check Now'; }, 1500);
            } else {
              btn.disabled=false; btn.textContent='Check Now';
              alert('Resolve request failed');
            }
          }catch(e){
            console.error('check now failed', e);
            btn.disabled=false; btn.textContent='Check Now';
            alert('Resolve request failed');
          }
        });
      });
    }

    async function loadDomains(){
      try{
        const resp = await fetch('/domains');
        if(!resp.ok){ console.warn('Failed to load /domains'); return; }
        const data = await resp.json();
        domainsCache = data.domains || [];
        renderDomains();
      }catch(e){ console.error('Failed to load domains', e); }
    }
    // load domains on start
    loadDomains();

    document.getElementById('refresh').addEventListener('click', ()=>load());
    load();
    // load settings into form
    async function loadSettings(){
      try{
        const r = await fetch('/settings');
        const j = await r.json();
        const alerts = (j.settings && j.settings.alerts) ? j.settings.alerts : (j.settings || {}).alerts || {};
        document.getElementById('teams_webhook').value = alerts.teams_webhook || '';
        document.getElementById('misp_url').value = alerts.misp_url || '';
        document.getElementById('misp_key').value = alerts.api_key || '';
        document.getElementById('push_event_id').value = alerts.push_event_id || '';
        document.getElementById('vt_api_key').value = alerts.vt_api_key || '';
      }catch(e){
        // ignore
      }
    }
    document.getElementById('load_settings').addEventListener('click', ()=>loadSettings());
    document.getElementById('save_settings').addEventListener('click', async ()=>{
      const alerts = {
        teams_webhook: document.getElementById('teams_webhook').value.trim(),
        misp_url: document.getElementById('misp_url').value.trim(),
        api_key: document.getElementById('misp_key').value.trim(),
        push_event_id: document.getElementById('push_event_id').value.trim(),
        vt_api_key: document.getElementById('vt_api_key').value.trim()
      };
      try{
        const r = await fetch('/settings', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({alerts})});
        const j = await r.json();
        if(j && j.status=='ok'){
          document.getElementById('settings_status').textContent = 'Saved.';
        } else {
          document.getElementById('settings_status').textContent = 'Save failed';
        }
      }catch(e){
        document.getElementById('settings_status').textContent = 'Save failed';
      }
      setTimeout(()=>{document.getElementById('settings_status').textContent='';},3000);
    });
    // auto-load settings once
    loadSettings();
    // auto-refresh every 60s
    setInterval(load, 60000);
  </script>
</body>
</html>
